# Chapter 2

## Rendering a collection, modules
- Some recap before diving into new territory

### console.log
- Experience JS developers use the log... a lot
- Don't concatenate things like `console.log('the value of props is' + props)` with a `+`, separate using a `,` like `console.log('the value of props is', props)` unless you like seeing `[Object object]` a lot

### Protip: Visual Studio Code snippets
- With VS Code you can create and use 'snippets', i.e. shortcuts for commonly used code portions
- Documentation on these snippets can be found below:
    - [About snippets](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets)
    - [React Snippet Plug-in](https://marketplace.visualstudio.com/items?itemName=xabikos.ReactSnippets)

### Javascript Arrays
- From now until the end of the course we'll be using the functional programming methods of JS arrays, e.g. `find`, `filter`, and `map` - so get used to it
- Links for help on functional programming in JS:
    - [Functional programming in JS](https://www.youtube.com/playlist?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84)
    - [Higher-order functions](https://www.youtube.com/watch?v=BMUiFMZr7vk&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84)
    - [Map](https://www.youtube.com/watch?v=bCqtb-Z5YGQ&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=2)
    - [Reduce basics](https://www.youtube.com/watch?v=Wl98eZpkp-c&t=31s)

### Event handlers revisited
 - Event handlers gave several people in the course some trouble, so if you're one of those people, look at:
    - [Event handlers revisited](https://fullstackopen.com/en/part1/a_more_complex_state_debugging_react_apps#event-handling-revisited)
    - [Revision on the topic](https://fullstackopen.com/en/part1/a_more_complex_state_debugging_react_apps#passing-event-handlers-to-child-components)  

## Review of concepts over... on to Chapter 2  

### Rendering collections
- We will now focus on the front-end with the following example:

```js
import React from 'react'
import ReactDOM from 'react-dom'

const notes = [
  {
    id: 1,
    content: 'HTML is easy',
    date: '2019-05-30T17:30:31.098Z',
    important: true
  },
  {
    id: 2,
    content: 'Browser can execute only JavaScript',
    date: '2019-05-30T18:39:34.091Z',
    important: false
  },
  {
    id: 3,
    content: 'GET and POST are the most important methods of HTTP protocol',
    date: '2019-05-30T19:20:14.298Z',
    important: true
  }
]

const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        <li>{notes[0].content}</li>
        <li>{notes[1].content}</li>
        <li>{notes[2].content}</li>
      </ul>
    </div>
  )
}

ReactDOM.render(
  <App notes={notes} />,
  document.getElementById('root')
)
```
- Each note contains its textual content, a timestamp, a unique id, and a boolean value indicating its importance

- Of course it is not practical to hardcode an index for each note we'd like to render

- Instead, we can generate React elements from the array using the **map** function

    ```js
    notes.map(note => <li>{note.content}</li>)
    ```

- We can then use this function within `<ul></ul>` tags and format appriately to get the following:

    ```js
    const App = (props) => {
        const { notes } = props

        return (
            <div>
                <h1>Notes</h1>
                <ul>
                    {notes.map(note => 
                    <li>
                        {note.content}
                    </li>
                    )}
                </ul>
            </div>
        )
    }
    ```

### Key-attribute
- The code from the above section will appear to work, but a message like the following appears in the browser console:
    ![](./images/UniqueKeyProp.png)

- As the [link](https://reactjs.org/docs/lists-and-keys.html#keys) in the message shows, the list items must each have a unique key value

- So let's add the keys:
    ```js
    const App = (props) => {
        const { notes } = props

        return (
            <div>
                <h1>Notes</h1>
                <ul>
                    {notes.map(note => 
                    <li key={note.id}>
                        {note.content}
                    </li>
                    )}
                </ul>
            </div>
        )
    }
    ```
- React needs this key attribute to determine how to update the view generated by a component when the component is re-rendered

### Map
- Let's take the array of notes from earlier to look at how the `map` function works:
    ```js
    const notes = [
        {
            id: 1,
            content: 'HTML is easy',
            date: '2019-05-30T17:30:31.098Z',
            important: true
        },
        {
            id: 2,
            content: 'Browser can execute only JavaScript',
            date: '2019-05-30T18:39:34.091Z',
            important: false
        },
        {
            id: 3,
            content: 'GET and POST are the most important methods of HTTP protocol',
            date: '2019-05-30T19:20:14.298Z',
            important: true
        }
    ]
    ```

- Say we add the following code:
    ```js
    const result = notes.map(note => note.id)
    console.log(result)
    ```
    - *[1, 2, 3]* will then be printed to the console
        - `map` creates a new array from the elements of the original array by *mapping* using the function given as paramater to the *map* method
        - The function is `note => note.id` AKA `(note) => {return note.id}`
        - The function gets a note object as a paramater and returns the value of its id field

- If we change the command to:
    ```js
    const result = notes.map(note => note.content)
    ```
    - We will get an array containing the content of the notes
    - This is pretty close to the React code we used in the previous section

- Just remember that when you need React to render something, it must be in curly braces `{}`
    ```js
    note => <li key={note.id}>{note.content}</li>
    ```
    - We need `{}` on `note.id` and `note.content` so that the actual value of the variables appears in our `<li></li>`

### Anti-pattern: array indexes as keys
- We could have made the key attribute error message from earlier disappear by using the array indexes as keys by passing a second paramater to the callback function of the map method:
    
    ```js
    notes.map((note, i) => ...)
    ```

- When called like this `i` is assigned the value of the index of the position in the array where the note resides - so you could do something like:

    ```js
    <ul>
        {notes.map((note, i) => 
            <li key={i}>
                {note.content}
            </li>
        )}
    </ul>
    ```

- **DO NOT DO THIS** - it can cause undesired problems even if it seems to work just fine.
    - [Read more](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318)

### Refactoring modules
- We can tidy the code up a bit by destructuring to grab just the `notes` field of the props and refactoring the note into its own component:

    ```js
    const Note = ({ note }) => {
        return (
            <li>{note.content}</li>
        )
    }

    const App = ({ notes }) => {
        return (
            <div>
                <h1>Notes</h1>
                <ul>
                    {notes.map(note => 
                        <Note key={note.id} note={note} />
                    )}
                </ul>
            </div>
        )
    }
    ```
- Note that the *key* attribute must now be defined for the `Note` component and not for the `<li></li>` tags like before

- Unlike we've been practicing so far, React applications are typically note written in a single file. Usually each component gets its own file as an *ES6-module*
    - Like we've seen when we write
        ```js
        import React from 'react'
        import ReactDOM from 'react-dom'
        ```
    - The above imports the modules `react` and `react-dom` and indicates they should be referenced by "React" and "ReactDOM", respectively

- In most relatively small applications components are placed in `./src/components` with the file being named after the component

- After refactoring into a module, our `Note` component looks like this:

    ```js
    import React from 'react'

    const Note = ({ note }) => {
        return (
            <li>{note.content}</li>
        )
    }

    export default Note
    ```
- Most notably here is the last line, in order to use our component elsewhere, we must first export it using `export default Note`
    - Then we can import the `Note` module in *index.js* by writing `import Note from './components/Note'`

- We repeat this process with our `App` component, placing it directly in the `~/src/` directory because it is the root of our application so that now *index.js* looks like this:
    ```js
    import React from 'react'
    import ReactDOM from 'react-dom'
    import App from './App'

    const notes = [
    // ...
    ]

    ReactDOM.render(
        <App notes={notes} />,
        document.getElementById('root')
    )
    ```

### When the application breaks
- Sometimes you're coding along, minding your own business when, seemingly out of nowhere, everything breaks down - especially in a dynamically typed language such as JS. It might look like this:

    ![](./images/JSExplosion.png)

- In these situations the best way out is `console.log` - the piece of code causing that message is this:

    ```js
    const Course = ({ course }) => (
        <div>
            <Header course={course} />
        </div>
    )

    const App = () => {
        const course = {
            // ...
        }

        return (
            <div>
            <Course course={course} />
            </div>
        )
    }
    ```
- We can hone in on the root issue by adding `console.log` commands to the code
    - We'll begin by adding one to the `App` component as it is the first thing to be rendered
    - We may also need to refactor some compactly-written components to allow for better logging:
        ```js
        const Course = ({ course }) => (
            <div>
                <Header course={course} />
            </div>
        )
        ```
        - becomes
        ```js
        const Course = ({ course }) => { 
            console.log(course)
            return (
                <div>
                    <Header course={course} />
                </div>
            )
        }
        ```

- Oftentimes the problem is that the props are expected to be of a different type or called with a different name than they actually are and destructuring fails - this may require us to remove destructuring and see what the `props` actually contain
    ```js
    const Course = (props) => {
        console.log(props)
        const { course } = props
        // ...
    ```

- If the problem *still* hasn't been resolved, more `console.log` statements and bug-hunting are required

## Forms
- We'd now like to add the ability to add new notes to our application - to do this we will define a piece of state in our `App` component that is initialized with the notes array passed from the props
    - Note that we're initializing our state with an array with the `useState` function

    ```js
    import React, { useState } from 'react'
    import Note from './components/Note'

    const App = (props) => {
        const [notes, setNotes] = useState(props.notes)

        return (
            <div>
                <h1>Notes</h1>
                <ul>
                    {notes.map(note => 
                        <Note key={note.id} note={note} />
                    )}
                </ul>
            </div>
        )
    }

    export default App
    ```
- Next, let's add an HTML form to the component that will be used for adding notes
    ```js
    const App = (props) => {
        const [notes, setNotes] = useState(props.notes)

        const addNote = (event) => {
            event.preventDefault()
            console.log('button clicked', event.target)
        }

        return (
            <div>
                <h1>Notes</h1>
                <ul>
                    {notes.map(note => 
                        <Note key={note.id} note={note} />
                    )}
                </ul>
                <form onSubmit={addNote}>
                    <input />
                    <button type="submit">save</button>
                </form>   
            </div>
        )
    }
    ```
- We have added the `addNote` function as an event handler to the form element that will be called when the form is submitted by clicking the submit button
    - The `event` parameter is the event that triggers the call to the event handler
    - The event handler calls `event.preventDefault()` to avoid the default action of form submission which would include a page reload

- To begin accessing the data in the form's input element, we add a new piece of state called `newNote` for storing input **and** we set it as the input element's *value* attribute
```js
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 

  const addNote = (event) => {
    event.preventDefault()
    console.log('button clicked', event.target)
  }

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input value={newNote} />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```
- However, this causes a console error as *'a new note...'* appears in the input element, but the input text can't be edited:

    ![](./images/ReadOnlyInput.png)

- In order to enable editing of the input element, we need another event handler to sync changes between `<input>` and the component's state
```js
const handleNoteChange = (event) => {
    console.log(event.target.value)
    setNewNote(event.target.value)
}
```
- and add it to the input element
```html
<form onSubmit={addNote}>
    <input
        value={newNote}
        onChange={handleNoteChange}
    />
    <button type="submit">save</button>
</form>
```
- The event handler is called every time *a change occurs in the input element*
    - The event object is received as the `event` parameter
    - The `target` property refers to the *input* element
    - `event.target.value` then refers to the input value of the element
    - We did not call `event.preventDefault()` because there is no default action on input change

- After these changes, the `newNote` state reflects the current value of the input, which means we can complete the `addNote` function for creating new notes:
    ```js
    const addNote = (event) => {
        event.preventDefault()
        const noteObject = {
            content: newNote,
            date: new Date().toISOString(),
            important: Math.random() < 0.5,
            id: notes.length + 1,
        }

        setNotes(notes.concat(noteObject))
        setNewNote('')
    }
    ```
    - The note content comes from the `newNote` state, which now reflects the `<input>` element on the page
    - The id comes from incrementing the length of the list of notes
        - This only works because we can't delete notes
    - By using `Math.random()` our note has a 50-50 shot of being marked as important
    - The note is added to the list using `concat`
        - Do not mutate state directly in React!!!!!!!
    - Lastly, we reset the value of the controlled input element by calling `setNewNote` of the `newNote` state

- Code for the above is [here](https://github.com/fullstack-hy2020/part2-notes/tree/part2-2)    

### Filtering displayed elements
- Now we want to add a filter to the app that only shows important notes - we can begin this by adding a piece of state to the `App` that keeps track of which notes should be displayed
    ```js
    const App = (props) => {
        const [notes, setNotes] = useState(props.notes) 
        const [newNote, setNewNote] = useState('')
        const [showAll, setShowAll] = useState(true)
        // ...
    ```

- We'll also change the component so it stores a list of all the notes to be displayed in the `notesToShow` variable where the items of this list depend on the state of the component:
    ```js
    const notesToShow = showAll
        ? notes
        : notes.filter(note => note.important === true)
    ```
    - and correspondingly we change the  `<ul>` tags of our return to only display those notes captured in our `notesToShow` function:
    ```js
    <div>
        <h1>Notes</h1>
        <ul>
            {notesToShow.map(note =>
                <Note key={note.id} note={note} />
            )}
        </ul>
        // ...
    </div>
    ```
    - This functions works by using the JS conditional operator
        - `const result = condition ? valIfTrue : valIfFalse`
    - In our case, if `showAll` is false - then we'll only show the notes marked as important, if `showAll` is true - then we'll show the whole notes list
    - We accomplish filtering by use of the `filter` method:
        - `array.filter(item => item.property === valueToFilterOn)`

- Lastly, let's add the ability to toggle the `showAll` state of the application from the user interface:
    ```js
    // ...
    return (
        // ...
        <h1>Notes</h1>
        <div>
            <button onClick={() => setShowAll(!showAll)}>
                show {showAll ? 'important' : 'all' }
            </button>
        </div>
        <ul>
            {notesToShow.map(note =>
                <Note key={note.id} note={note} />
            )}
        </ul>
        // ...
    )
    ```
    - The displayed notes are now controlled with a button whose event handler, `() => setShowAll(!showAll)`, is so simple that we define it directly in the attribute of the button element
        - The text of the button also depends on the value of the `showAll` state

## Getting data from the server

### The browser as a runtime environment

### npm

### Axios and promises

### Effect-hooks

### The development runtime environment

## Altering data in the server

### REST

### Sending data to the server

### Changing the importance of notes

### Extracting communication with the backend into a separate module

### Cleaner syntax for defining object literals

### Promises and errors

## Adding styles to React app

### Improved error message

### Inline styles
